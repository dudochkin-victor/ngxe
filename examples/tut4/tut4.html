<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.0  (Linux)">
	<META NAME="CREATED" CONTENT="20050624;15142300">
	<META NAME="CHANGED" CONTENT="20050711;23020200">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 ALIGN=CENTER>Tutorial 4</H1>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>Introduction</FONT></FONT></P>
<P>Hi again. You ready to do some more opengl? I've been thinking
that the aim of these tutorials should be more towards game
programming than towards opengl. But then off course we need to first
get grabs on openGL. And SDL off course. I'm thinking about doing a
openAL tutorial soon in the future.</P>
<P>This tutorial will be on:<BR><U>Part 1</U> &ndash; Culling <BR>This
will be very short with no example code. As this technique is fairly
simple.<BR><U>Part 2</U> - Display Lists<BR>A very kewl thing to use
to enhance performance.<BR><U>Part 3</U> &ndash; OpenGL Errors</P>
<P>Lets go...</P>
<H1>Part1 &ndash; Culling</H1>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>What
is culling?</FONT></FONT></P>
<P>Imagine we have model. (The pyramid in previous models will do
fine) Now the model is like a shell. With a inside and a outside. But
as long as we are on the outside we don't see the inside.. logic!<BR>Now
every face of the model has 2 sides. OpenGL talks about the FRONT and
BACK. But for model purposes we may talk about the inside and outside
of the face. Now since we make the assumption that we are on the
outside of the model we never want to see any inside faces drawn. Off
course the Depth buffer takes care of this, but your graphics card
spends much valuable time drawing these faces only to have them
covered later.</P>
<P>Now what culling is it tells opengl not to draw the specific side
of a polygon. So if we get things setup so that the FRONT face is
always the outside face and then tell opengl to cull all the BACK
faces the result on the screen will be exactly the same but we gain
some increase in speed. Nice hey.</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>How
todo culling</FONT></FONT></P>
<P>Well firstly we need to make sure the front side of the face is on
the outside. Opengl specify that by default polygons (triangles and
squares mostly) are drawn by specifying the points Clock-Wise. We can
change the way opengl sees this by using <B>glFrontFace(mode)</B> and
specifying either <B>GL_CW</B> or <B>GL_CCW</B>(counter-clockwise). 
</P>
<P>Now we need to tell Opengl which face(s) to Cull using
<B>glCullFace(mode)</B>. Normally we will specify <B>GL_BACK</B>. And
then turn on culling using <B>glEnable(GL_CULL_FACE)</B>. 
</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>Culling
in practise</FONT></FONT></P>
<P>Culling is used in almost all opengl applications and is fairly
simple to get working. When you load models generated by a program
they are usually setup so that culling will work. Or we hope so
anyways.</P>
<P>Simply turning on Culling can have strange effects in your
application if things are wrong and you might have trouble finding
the missing polygons. It might make sense to first only tell opengl
to draw the back faces in a different way using
<B>glPolygonMode(GL_BACK,GL_LINE)</B> this will draw the BACK faces
wire-frame. (note: this is actually slower many times than drawing
the complete filled textured face, but helps with the development of
the software)</P>
<P STYLE="font-weight: medium">Thats it for Culling! Great stuff
:)<BR>(I really didn't think an example necessary)</P>
<H1>Part 2 &ndash; Display Lists</H1>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>What
and why?</FONT></FONT></P>
<P>When you issue a command to opengl (like glVertex for example)
some things must happen. Firstly your program must maybe find
variables or even compute expressions for the values to use. Then it
must send these new commands and values from the cpu/memory to your
graphics card where finally it can be executed.</P>
<P>This seems fine for a while. But what if we tend to execute the
same set of commands over and over again and again. Then it seem
stupid to recompute everything every time. Now you can with your
application pre-compute some values at the expense of memory. But you
are still stuck at sending those bunch of commands to the graphics
card every time. These system calls takes time and there is only that
much bandwidth available. (Yes even your new PCI express 16x has its
limits!)</P>
<P>The solution is Display lists! Display lists are a bunch of
commands compiled into a list that the graphics card can keep in its
memory. And then we can simply tell the graphics card to execute a
given list. This sending one command to the graphics card and
executing all of them. 
</P>
<P>The only problem is that all values in the display list is fixed.
So changing the variables in your program used to compute the values
used in the commands will not affect the display list. The only way
to change the data used in a display list is to recompile the display
list. We can make things a little easier by using display lists
recursively. (ie. display lists have commands that call other display
lists.) The trick is to find the regions of code that you can compile
into display lists and thus making your application faster.</P>
<P>But remember we can call some commands like glRotate or
glTranslate outside executing the display list thus calling the
display list with seemingly different results.</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>How
display lists work in OpenGL</FONT></FONT></P>
<P>Display lists are easy to use!</P>
<P>Go look in the example <U>lists1.cpp</U> in the <B>makelist</B>
function.</P>
<P>The display list is identified by a simple number. We declared
<B>Gluint displaylist1</B> at the top of the program.<BR>Firstly we
call <B>glGenLists</B> to generate the display list. We can generate
more than one display list using but for this example 1 is all we
need. 
</P>
<P>Now we want to compile the list and call <B>glNewList(listname,mode)</B>
with <B>GL_COMPILE</B>. <BR>GL_COMPILE tells opengl we only want to
create the list. So the commands aren't executed but only stored in
the list. The alternative is <B>GL_COMPILE_AND_EXECUTE</B> which both
executes the commands and put the in the list.</P>
<P>Next we call the <B>drawpiramid</B> function. This is the code
from Tutorial 2. What happens is that the piramid isn't actually
drawn but the commands to draw the pyramid are put in the display
list.</P>
<P>Lastly we finish the list compilation with <B>glEndList()</B>. Now
the list is ready for usage. Note that every glNewList commands must
have a glEndList command.</P>
<P>In the main loop you see <B>glCallList(list)</B> commands. This
tells opengl to execute all the commands in the list. The example
draws the pyramid twice at different locations. 
</P>
<P>I hope you agree with me that display lists is easy to use.</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>What
more</FONT></FONT></P>
<P>Well in a real application changes are you will create lotsa
display lists on the fly. And they will only be used for maybe a
short time. So I the last command you must now of is
<B>glDeleteLists(list,range)</B>. This can be used to delete lists
created by <B>glGenLists</B> and free up the memory used by the
display list. As display lists can quickly start to eat away at the
graphics cards memory. You can off course simply overwrite old
display lists with <B>glNewList</B>.</P>
<P>I've also created an example called <U>lists2.cpp</U>. In this
example you can change the heights of the pyramids using the A,Z and
S,X keys for the different pyramids. Check the code out:<BR>The first
pyramids display list is updated immediately when the height change
as normally.<BR>But the second pyramid only set a variable mod2 to
true which instructs the code that draws the pyramid to recreate the
pyramid which then uses GL_COMPILE_AND_EXECUTE to update the list
while simultaneously drawing the pyramid with it's new height.</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>Last
notes on display lists</FONT></FONT></P>
<P>Well there aint much more to say about display lists. Probably the
only drawback of display lists is that they can take up huge amounts
of memory. This can sometimes be decreased by using nested display
lists. But this again makes the process slower. So the trick is to
find the balance.</P>
<P>Use display lists also for not geometry stuff like rotations and
matrix manipulations. Putting a glRotate command in a display list
hugely optimize the command. 
</P>
<P>In some cases display lists is a bad idea. And we will look at
vertex arrays in one of the next tutorials as an alternative way to
speed up drawing geometry.</P>
<P>I've created a <B>GLListsclass</B>. Which is in lists.cpp and
lists.h take a look if your interested. I will be using this class in
future examples to simplify the usage of the already simple-to-use
display lists.</P>
<H1>Part 3 &ndash; OpenGL errors</H1>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>Introduction</FONT></FONT></P>
<P>While you are hapily coding things might just go wrong. And it is
best to catch errors early on. So all I'm trying to teach you hear is
how to check if everything is still ok every so often.</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>OpenGL
errors</FONT></FONT></P>
<P>When something goes wrong opengl sets an error state.<BR>The error
state can be checked with the <B>glGetError</B> command.<BR>If
GL_NO_ERROR is returned everything is returned. 
</P>
<P>You can check out the help file(manpage) for every command to see
what Errors it can be generated.<BR>Please note that you <U>may not</U>
call <B>glGetError</B> inside a glBegin/glEnd block.</P>
<P>I've created a name space calls GLError in error.cpp and error.h
and a small example in error1.cpp.<BR>In basic it gives you the
ability to simply put in the statement <B>CHECKGLSILENT</B> in places
in your code and then it will check for opengl errors and give you
debugging output if something goes wrong. To disable these checks in
the end remove <B>#include &ldquo;error.h&rdquo;</B> and add <B>#define
CHECKGLSILENT</B></P>
<P>That's it for this :)</P>
<P STYLE="margin-top: 0.17in; page-break-after: avoid"><FONT FACE="Albany, sans-serif"><FONT SIZE=4>Last
for this tutorial</FONT></FONT></P>
<P>So that is this for this tutorial. Sorry there wasn't much
visually stunning to see in this tutorial. I'll try to improve on
this lack in the next tutorial. 
</P>
<P>In the next tutorial we will implement a sky-box among some other
things.</P>
<P>Cheerios<BR>-Heinrich</P>
<P><BR><BR>
</P>
<P><FONT SIZE=1 STYLE="font-size: 8pt">Copyright (c)  2005   Heinrich
du Toit.<BR>      Permission is granted to copy, distribute and/or
modify this<BR>document under the terms of the GNU Free Documentation
License, Version 1.2<BR>or any later version published by the Free
Software Foundation;<BR>with no Invariant Sections, no Front-Cover
Texts, and no<BR>Back-Cover Texts. A copy of the license is included
in the file named<BR>&quot;copyright&quot; which might be distributed
along with this document or it can be obtained<BR>electronically at
www.fsf.org or www.opensource.org/licenses</FONT></P>
</BODY>
</HTML>